<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>busytex</title>
    <link
      rel="stylesheet"
      href="https://unpkg.com/xterm@3.8.0/dist/xterm.css"
    />
    <style>
        body {
            height: 100vh;
            padding: 0; 
            margin: 0;
        }

        #fileupload {
            display: none;
        }

        #viewer {
            width: 50%;
        }

        #editor {
            width: 50%; 
            border: 1px solid grey;
        }

        #terminal {
            width: 100%; 
            height: 70%;
        }

        #status {
            width: 100%;
            height: 30%;
            padding: 5px;
            margin: 0;
            resize: none;
            box-sizing: border-box;
        }

        #pdfpreview {
            width: 99%;
            height: 100%;
        }
    </style>
  </head>
  <body>
    <div style="display: flex; height: 50%">
      <div id="editor"></div>
      <div id="viewer">
        <iframe id="pdfpreview"></iframe>
        <img hidden id="imgpreview"></img>
      </div>
    </div>
    <div style="display: flex; flex-direction: column; height: 50%">
      <div id="terminal"></div>
      <textarea
        name="status"
        id="status"
        cols="1"
        rows="1"
      ></textarea>
      <input type="file" id="fileupload">
    </div>

    <script src="https://unpkg.com/monaco-editor@latest/min/vs/loader.js"></script>
    <script src="/busytex.pipeline.js"></script>

    <template id="helloworld">JVBERi0xLjcKCjEgMCBvYmogICUgZW50cnkgcG9pbnQKPDwKICAvVHlwZSAvQ2F0YWxvZwogIC9QYWdlcyAyIDAgUgo+PgplbmRvYmoKCjIgMCBvYmoKPDwKICAvVHlwZSAvUGFnZXMKICAvTWVkaWFCb3ggWyAwIDAgMjAwIDIwMCBdCiAgL0NvdW50IDEKICAvS2lkcyBbIDMgMCBSIF0KPj4KZW5kb2JqCgozIDAgb2JqCjw8CiAgL1R5cGUgL1BhZ2UKICAvUGFyZW50IDIgMCBSCiAgL1Jlc291cmNlcyA8PAogICAgL0ZvbnQgPDwKICAgICAgL0YxIDQgMCBSIAogICAgPj4KICA+PgogIC9Db250ZW50cyA1IDAgUgo+PgplbmRvYmoKCjQgMCBvYmoKPDwKICAvVHlwZSAvRm9udAogIC9TdWJ0eXBlIC9UeXBlMQogIC9CYXNlRm9udCAvVGltZXMtUm9tYW4KPj4KZW5kb2JqCgo1IDAgb2JqICAlIHBhZ2UgY29udGVudAo8PAogIC9MZW5ndGggNDQKPj4Kc3RyZWFtCkJUCjcwIDUwIFRECi9GMSAxMiBUZgooSGVsbG8sIHdvcmxkISkgVGoKRVQKZW5kc3RyZWFtCmVuZG9iagoKeHJlZgowIDYKMDAwMDAwMDAwMCA2NTUzNSBmIAowMDAwMDAwMDEwIDAwMDAwIG4gCjAwMDAwMDAwNzkgMDAwMDAgbiAKMDAwMDAwMDE3MyAwMDAwMCBuIAowMDAwMDAwMzAxIDAwMDAwIG4gCjAwMDAwMDAzODAgMDAwMDAgbiAKdHJhaWxlcgo8PAogIC9TaXplIDYKICAvUm9vdCAxIDAgUgo+PgpzdGFydHhyZWYKNDkyCiUlRU9G</template>
    <script>
    function delay(seconds)
    {
        return new Promise(resolve => setTimeout(resolve, seconds * 1000));
    }

    function base64_encode_utf8(str)
    {
        return btoa(encodeURIComponent(str).replace(/%([0-9A-F]{2})/g, function(match, p1) {return String.fromCharCode(parseInt(p1, 16)) }));
    }

    function network_error(resp)
    {
        return new Error(`${resp.status}: ${resp.statusText}`);
    }

    class Guthub
    {
        constructor(FS, auth_token, println)
        {
            this.retry_delay_seconds = 2;
            this.auth_token = auth_token;
            this.println = println || (line => null);
            this.FS = FS;
        }

        github_api_request(https_path, relative_url, method, body)
        {
            const api = https_path.replace('github.com', 'api.github.com/repos');
            return fetch(api + relative_url, Object.assign({method : method || 'get', headers : Object.assign({Authorization : 'Basic ' + btoa(this.auth_token)}, body != null ? {'Content-Type' : 'application/json'} : {})}, body != null ? {body : JSON.stringify(body)} : {}));
        }

        read_https_path()
        {
            return this.FS.readFile('.git/config', {encoding : 'utf8'}).split('\n')[1].split(' ')[2];
        }

        read_githubcontents()
        {
            const path = '.git/githubapicontents.json';
            return Fthis.S.analyzePath(path).exists ? JSON.parse(FS.readFile(path, {encoding : 'utf8'})) : [];
        }
        
        async clone(https_path, repo_path)
        {
            this.println(`Cloning into '${repo_path}'...`);
            const resp = await this.github_api_request(https_path, '/contents');
            const repo = await resp.json();
            this.println(`remote: Enumerating objects: ${repo.length}, done.`);

            FS.mkdir(repo_path);
            FS.mkdir(repo_path + '/.git');
            FS.writeFile(repo_path + '/.git/config', '[remote "origin"]\nurl = ' + https_path);
            FS.writeFile(repo_path + '/.git/githubapicontents.json', JSON.stringify(repo));
            
            while(repo.length > 0)
            {
                const file = repo.pop();
                if(file.type == 'file')
                {
                    const resp = await fetch(file.download_url);
                    const contents = new Uint8Array(await resp.arrayBuffer());
                    const file_path = repo_path + '/' + file.path;
                    this.FS.writeFile(file_path, contents, {encoding: 'binary'});
                }
                else if(file.type == 'dir')
                {
                    this.FS.mkdir(repo_path + '/' + file.path);
                    const resp = await this.github_api_request(https_path, '/contents/' + file.path);
                    const dir = await resp.json();
                    repo.push(...dir);
                }
            }
            this.println(`Unpacking objects: 100% (${repo.length}/${repo.length}), done.`);
        }
    
        async push(file_path, message, retry)
        {
            const content = this.FS.readFile(file_path, {encoding : 'utf8'});
            let sha = this.read_githubcontents().filter(f => f.path == file_path);
            sha = sha.length > 0 ? sha[0].sha : null;
            const resp = await this.github_api_request(this.read_https_path(), '/contents/' + file_path, 'put', Object.assign({message : `${file_path}: ${message}`, content : base64_encode_utf8(content)}, sha ? {sha : sha} : {}));
            if(resp.ok)
                sha = (await resp.json()).content.sha;
            else if(resp.status == 409 && retry != false)
            {
                console.log('retry not implemented');
                //await delay(this.retry_delay_seconds);
                //await this.put(message, sha ? ((await this.init_doc()) || this.sha) : null, false);
            }
            else
                throw network_error(resp);
        }
    }

    function modularized_module(thisProgram, preRun, println)
    {
        const Module =
        {
            noInitialRun : true,

            thisProgram : thisProgram,

            preRun : [preRun],
            
            print(text) 
            {
                Module.setStatus('stdout: ' + (arguments.length > 1 ?  Array.prototype.slice.call(arguments).join(' ') : text));
            },

            printErr(text)
            {
                Module.setStatus('stderr: ' + (arguments.length > 1 ?  Array.prototype.slice.call(arguments).join(' ') : text));
            },
            
            setStatus(text)
            {
                println((this.statusPrefix || '') + text);
            },
            
            monitorRunDependencies(left)
            {
                this.totalDependencies = Math.max(this.totalDependencies, left);
                Module.setStatus(left ? 'Preparing... (' + (this.totalDependencies-left) + '/' + this.totalDependencies + ')' : 'All downloads complete.');
            },
            
            totalDependencies: 0,
        };
        return Module;
    }

    class Shell
    {
        constructor(FS, term, compiler, println)
        {
            this.home = '/home/web_user';
            this.term = term;
            this.FS = FS;
            this.compiler = compiler;
            this.println = println;
            
            this.github_auth_token = window.location.hash || '';
            if(this.github_auth_token.length > 1)
                this.github_auth_token = this.github_auth_token.slice(1);

            this.github_https_path = window.location.search || '';
            if(this.github_https_path.length > 1)
                this.github_https_path = 'https://github.com' + this.github_https_path.slice(1);
            
            this.guthub = new Guthub(this.FS, self.github_auth_token, println);
            this.tic_ = 0;
            this.pdf_path = '';
        }

        tic()
        {
            this.tic_ = performance.now();
        }

        toc()
        {
            const elapsed = (performance.now() - this.tic_) / 1000.0;
            window.println(`Elapsed time: ${elapsed.toFixed(2)} sec`);
        }

        async onload()
        {
            if(this.github_https_path.length > 0)
            {
                const repo_path = await this.clone(this.github_https_path);
                this.cd(repo_path);
            }
        }

        open(file_path, contents)
        {
            if(file_path.endsWith('.pdf') || file_path.endsWith('.jpg') || file_path.endsWith('.png') || file_path.endsWith('.svg'))
            {
                contents = contents || this.FS.readFile(file_path, {encoding : 'binary'});
                
                const imgpreview = document.getElementById('imgpreview'), pdfpreview = document.getElementById('pdfpreview');
                if(file_path.endsWith('.svg'))
                {
                    imgpreview.src = 'data:image/svg+xml;base64,' + btoa(String.fromCharCode.apply(null, contents));
                    [imgpreview.hidden, pdfpreview.hidden] = [false, true];
                }
                else if(file_path.endsWith('.png') || file_path.endsWith('.jpg'))
                {
                    const ext = file_path.endsWith('.png') ? 'png' : 'jpg';
                    imgpreview.src = `data:image/${ext};base64,` + btoa(String.fromCharCode.apply(null, contents));
                    [imgpreview.hidden, pdfpreview.hidden] = [false, true];
                }
                else if(file_path.endsWith('.pdf'))
                {
                    document.getElementById('pdfpreview').src = URL.createObjectURL(new Blob([contents], {type: 'application/pdf'}));
                    [imgpreview.hidden, pdfpreview.hidden] = [true, false];
                }
            }
            else
            {
                contents = contents || this.FS.readFile(file_path, {encoding : 'utf8'});
                window.editor.getModel().setValue(contents);
            }
        }

        help()
        {
            return ['help', 'latexmk', 'download', 'clear', 'pwd', 'ls', 'mkdir', 'cd', 'clone', 'push', 'open', 'save'].sort();
        }

        save(file_path, contents)
        {
            this.FS.writeFile(file_path, contents);
        }

        pwd(replace_home)
        {
            const cwd = this.FS ? FS.cwd() : this.home;
            return replace_home == true ? cwd.replace(this.home, '~') : cwd;    
        }
        
        clear()
        {
            this.term.write('\x1bc');
        }

        ls(path)
        {
            return Object.keys(this.FS.lookupPath(path || '.').node.contents);
        }
        
        cd(path)
        {
            //const expanduser = path => return path.replace('~', this.home);
            this.FS.chdir(path);
        }

        mkdir(path)
        {
            this.FS.mkdir(path);
        }

        async latexmk(tex_path, bibtex)
        {
            this.println('Running in background...');
            this.tic();
            const traverse = (root, relative_dir_path) =>
            {
                let entries = [];
                for(const [name, entry] of Object.entries(this.FS.lookupPath(`${root}/${relative_dir_path}`, {parent : false}).node.contents))
                {
                    const relative_path = `${relative_dir_path}/${name}`;
                    const absolute_path = `${root}/${relative_path}`;
                    if(entry.isFolder)
                        entries.push({path : relative_path}, ...traverse(root, relative_path));
                    else
                        entries.push({path : relative_path, contents : this.FS.readFile(absolute_path, {encoding : 'binary'})});
                }
                return entries;
            };

            const pdf_path = tex_path.replace('.tex', '.pdf');
            const cwd = this.FS.cwd();
            console.assert(tex_path.endsWith('.tex'));
            console.assert(cwd.startsWith(this.home));
            
            // /home/web_user/project
            const project_dir = cwd.split('/').slice(0, 4).join('/');
            const source_path = `${cwd}/${tex_path}`;
            const main_tex_path = source_path.slice(project_dir.length + 1);

            const files = traverse(project_dir, '.');
            //const pdf = await this.compiler.compile(files, main_tex_path, bibtex);
            this.pdf_path = pdf_path;
            this.compiler.postMessage({files : files, main_tex_path : main_tex_path, bibtex : bibtex});
            //this.FS.writeFile(pdf_path, pdf);
            //this.open(pdf_path, pdf);
        }

        async upload(file_path)
        {
            const fileupload = document.getElementById('fileupload');
            const reader = new FileReader();
            return new Promise((resolve, reject) =>
            {
                reader.onloadend = () => {
                    this.FS.writeFile(file_path, new Uint8Array(reader.result));
                    resolve(`Local file [${fileupload.files[0].name}] uploaded into [${file_path}]`);
                };
                fileupload.onchange = () => reader.readAsArrayBuffer(fileupload.files[0]);
                fileupload.click();
            });
        }
    
        download(file_path, mime)
        {
              mime = mime || "application/octet-stream";

              let content = FS.readFile(file_path);
              console.log(`Offering download of "${file_path}", with ${content.length} bytes...`);

              var a = document.createElement('a');
              a.download = file_path;
              a.href = URL.createObjectURL(new Blob([content], {type: mime}));
              a.style.display = 'none';

              document.body.appendChild(a);
              a.click();
              setTimeout(() => {
                  document.body.removeChild(a);
                  URL.revokeObjectURL(a.href);
              }, 2000);
        }
        
        async clone(https_path)
        {
            const repo_path = https_path.split('/').pop();
            await this.guthub.clone(https_path, repo_path);
            return repo_path;
        }

        async push(relative_file_path)
        {
            await this.guthub.push(relative_file_path, 'guthub');
        }
    }
    
    var cur_line = '';
    const onkey = async (key, ev) =>
    {
        const ok = 'ok!';
        if(ev.keyCode == 8)
        {
            if(cur_line.length > 0)
            {
                cur_line = cur_line.slice(0, cur_line.length - 1);
                window.terminal.write('\b \b');
            }
        }
        else if(ev.keyCode == 13)
        {
            window.terminal.println();
            const [cmd, arg] = cur_line.split(' ');
            try
            {
                if (cmd == '')
                {
                }
                else if(cmd == 'clear')
                {
                    shell.clear();
                }
                else if(cmd == 'help')
                {
                    window.terminal.println(shell.help().join(' '));
                }
                else if(cmd == 'download')
                {
                    shell.download(arg);
                    window.terminal.println(ok);
                }
                else if(cmd == 'upload')
                {
                    window.terminal.println(await shell.upload(arg));
                }
                else if(cmd == 'latexmk')
                {
                    await shell.latexmk(arg, true);
                }
                else if(cmd == 'pwd')
                {
                    window.terminal.println(shell.pwd());
                }
                else if(cmd == 'ls')
                {
                    const res = shell.ls(arg);
                    if(res.length > 0)
                        window.terminal.println(res.join(' '));
                }
                else if(cmd == 'mkdir')
                {
                    shell.mkdir(arg);
                }
                else if(cmd == 'cd')
                {
                    shell.cd(arg);
                }
                else if(cmd == 'clone')
                {
                    await shell.clone(arg);
                }
                else if(cmd == 'push')
                {
                    await shell.push(arg);
                    window.terminal.println(ok);
                }
                else if(cmd == 'open')
                {
                    shell.open(arg);
                }
                else if(cmd == 'save')
                {
                    shell.save(arg, window.editor.getModel().getValue());
                }
                else
                {
                    window.terminal.println(cmd + ': command not found');
                }
            }
            catch(err)
            {
                window.terminal.println('Error: ' + err.message);
            }
            window.terminal.prompt();
            cur_line = '';
        }
        else
        {
            cur_line += key;
            window.terminal.write(key);
        }
    };

    require.config({
        paths: {
          vs: 'https://unpkg.com/monaco-editor@latest/min/vs',
          xterm: 'https://unpkg.com/xterm@3.8.0/dist'
        }
      })

      // Before loading vs/editor/editor.main, define a global MonacoEnvironment that overwrites
      // the default worker url location (used when creating WebWorkers). The problem here is that
      // HTML5 does not allow cross-domain web workers, so we need to proxy the instantiation of
      // a web worker through a same-domain script
      window.MonacoEnvironment = {
        getWorkerUrl: function (workerId, label) {
          return `data:text/javascript;charset=utf-8,${encodeURIComponent(`
              self.MonacoEnvironment = {
                baseUrl: 'https://unpkg.com/monaco-editor@latest/min/'
              };
              importScripts('https://unpkg.com/monaco-editor@latest/min/vs/base/worker/workerMain.js');`)}`
        }
      }

      require([
        'vs/editor/editor.main',
        'xterm/xterm',
        'xterm/addons/fit/fit',
        './dist/emscriptenfs',
      ], async function (editor, Terminal, fit, emscriptenfs) {

        window.editor = editor.editor.create(document.getElementById('editor'), {
          theme: 'vs-dark'
        })

        Terminal.applyAddon(fit)
        window.terminal = new Terminal()
        window.terminal.open(document.getElementById('terminal'))
        window.terminal.on('key', onkey);
        window.terminal.prompt = () => window.terminal.write('\x1B[1;3;31memscripten\x1B[0m:' + new Shell(typeof(FS) == 'undefined' ? null : FS, window.terminal).pwd(true) + '$ ');
        window.terminal.println = line => window.terminal.write((line || '') + '\r\n');
        window.println = text =>
        {
            let statusElement = document.getElementById('status');
            statusElement.value += text;
            statusElement.value += '\n';
            statusElement.scrollTop = statusElement.scrollHeight;
        };
        
        const Module = await emscriptenfs(modularized_module(null, () =>  {}, window.println));
        window.FS = Module.FS;
        window.FS.chdir('/home/web_user')

        const busytex_js = '/dist/busytex.js', busytex_wasm = '/dist/busytex.wasm';
        const busytex_worker_js = '/busytex.worker.js', busytex_pipeline_js = '/busytex.pipeline.js';
        
        //window.compiler = new BusytexPipeline(busytex_js, busytex_wasm, window.println, BusytexDefaultScriptLoader);
        window.compiler = new Worker(busytex_worker_js);
        window.compiler.onmessage = e =>
        {
            const {pdf, log} = e.data;
            if(pdf)
            {
                window.shell.toc();
                shell.FS.writeFile(shell.pdf_path, pdf);
                shell.open(shell.pdf_path, pdf);
            }
            else if(log)
            {
                window.println(log);
            }
        }
        window.compiler.postMessage({busytex_js : busytex_js, busytex_wasm : busytex_wasm});
              
        window.shell = new Shell(window.FS, window.terminal, window.compiler, window.terminal.println);

        window.editor.layout()
        window.terminal.fit()
        window.onresize = () =>
        {
            window.editor.layout()
            window.terminal.fit()
        };
        
        window.shell.open('helloworld.pdf', atob(document.getElementById('helloworld').innerHTML));
        
        await window.shell.onload();
        window.terminal.prompt();
      })
    </script>
  </body>
</html>
